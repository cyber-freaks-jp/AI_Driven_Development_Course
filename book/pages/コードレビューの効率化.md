# コードレビューの効率化

実装が完了したら、コードレビューを行います。AIを活用することで、コードレビューの効率と品質を大幅に向上させることができます。

## 従来のコードレビューの課題

### 時間がかかる

```
人間が全てのコードを読む → 1時間〜数時間
    ↓
フィードバック → 開発者が修正 → 再レビュー
    ↓
繰り返し...
```

大規模な変更の場合、レビューに膨大な時間がかかります。

### 見落としが発生する

- 人間は疲労する
- 注意力に限界がある
- 特定の観点（セキュリティなど）に詳しくないと見落とす

### フィードバックが遅れる

レビュアーが忙しいと、フィードバックが遅れて開発速度が低下します。

## AIによるコードレビューの自動化

マークダウン駆動開発では、要件定義書と設計書がマークダウンで存在するため、AIに正確な情報を与えてレビューさせることができます。

### レビューの流れ

```
実装コード + 設計書 + 要件定義書
    ↓ AIに読み込ませる
AIがコードレビュー
    ↓ フィードバック
開発者が修正
    ↓ 人間が最終確認
```

## CursorでAIにコードレビューさせる

### ステップ1：基本的なコードレビュー

実装したコードをAIにレビューさせます。

```
プロンプト例：
「@backend/src/routes/auth.ts をコードレビューしてください。
以下の観点でチェックしてください：
- コードの品質（可読性、保守性）
- エラーハンドリング
- セキュリティ
- パフォーマンス
- ベストプラクティスとの照合

問題があれば、具体的な改善案を提示してください。」
```

AIが以下のようにレビュー結果を返します：

```markdown
## コードレビュー結果

### 【重大】セキュリティ問題
**問題箇所**：
\`\`\`typescript
const hashedPassword = bcrypt.hashSync(password, 10);
\`\`\`

**問題点**：
bcrypt.hashSync()は同期処理のため、パスワードハッシュ化中にサーバーがブロックされます。

**改善案**：
\`\`\`typescript
const hashedPassword = await bcrypt.hash(password, 10);
\`\`\`

---

### 【警告】エラーハンドリング
**問題箇所**：
\`\`\`typescript
const user = await prisma.user.create({ data: { email, password: hashedPassword } });
\`\`\`

**問題点**：
メールアドレス重複時のエラーハンドリングが不足しています。

**改善案**：
\`\`\`typescript
try {
  const user = await prisma.user.create({ data: { email, password: hashedPassword } });
} catch (error) {
  if (error.code === 'P2002') {
    throw new Error('このメールアドレスは既に登録されています');
  }
  throw error;
}
\`\`\`

---

### 【推奨】パフォーマンス
**問題箇所**：
\`\`\`typescript
const existingUser = await prisma.user.findUnique({ where: { email } });
if (existingUser) {
  throw new Error('既に登録されています');
}
const user = await prisma.user.create({ data: { email, password: hashedPassword } });
\`\`\`

**問題点**：
存在チェックと作成の2回クエリが実行されています。

**改善案**：
作成時のユニーク制約違反でキャッチする方が効率的です（上記参照）。
```

### ステップ2：設計書との整合性をチェック

設計書と実装コードを比較して、齟齬がないかチェックします。

```
プロンプト例：
「@Docs/設計書.md と @backend/src/routes/auth.ts を比較してください。
設計書の仕様と実装に齟齬がないか確認してください。
もし齟齬があれば、具体的に指摘してください。」
```

AIの指摘例：

```
## 設計書との齟齬

1. **レスポンスステータスコード**
   - 設計書：登録成功時は 201
   - 実装：200 になっている
   → 設計書に合わせて 201 に修正すべき

2. **エラーレスポンス形式**
   - 設計書：{ "status": "error", "message": "..." }
   - 実装：{ "error": "..." }
   → 設計書の形式に統一すべき

3. **JWTトークンの有効期限**
   - 設計書：24時間
   - 実装：7日になっている
   → 設計書に合わせて修正するか、設計書を更新すべき
```

### ステップ3：要件定義書との整合性をチェック

要件定義書の要件を満たしているかチェックします。

```
プロンプト例：
「@Docs/要件定義書.md と @backend/src/routes/auth.ts を比較してください。
要件定義書の「2.1 ユーザー登録・ログイン機能」の要件を満たしているか確認してください。
不足している機能があれば指摘してください。」
```

AIの指摘例：

```
## 要件定義書との照合結果

### 実装済み
✅ メールアドレスによるユーザー登録
✅ パスワードは8文字以上
✅ パスワードのハッシュ化

### 未実装（要件定義書に記載あり）
❌ メール認証必須
❌ パスワードリセット機能
❌ OAuth認証（Google、GitHub）
❌ 2要素認証（2FA）

### 推奨
要件定義書の全機能を実装するか、要件定義書を現実的な範囲に更新することを推奨します。
```

## AIに改善案を実装させる

AIが指摘した問題を、そのままAIに修正させることができます。

```
プロンプト例：
「先ほど指摘した以下の問題を修正してください：
1. bcrypt.hashSync()をbcrypt.hash()に変更
2. メールアドレス重複時のエラーハンドリング追加
3. レスポンスステータスコードを201に変更

@backend/src/routes/auth.ts を修正してください。」
```

## セキュリティレビューに特化

セキュリティに特化したレビューも可能です。

```
プロンプト例：
「@backend/src/routes/ 配下の全ファイルをセキュリティレビューしてください。
OWASP Top 10 の観点で以下をチェックしてください：
- SQLインジェクション
- XSS
- CSRF
- 認証・認可の不備
- 機密情報の漏洩
- 暗号化の不備

脆弱性があれば、具体的な修正案を提示してください。」
```

## パフォーマンスレビュー

パフォーマンスの問題もAIでチェックできます。

```
プロンプト例：
「@backend/src/routes/tasks.ts をパフォーマンスレビューしてください。
以下の観点でチェックしてください：
- N+1クエリ問題
- 不要なループ
- 非効率なデータ構造
- キャッシュの活用不足

問題があれば、具体的な改善案を提示してください。」
```

## 人間による最終レビュー

AIのレビュー結果を参考に、人間が最終的にレビューします。

### 人間がチェックすべきこと

| AIが得意 | 人間が得意 |
|---------|-----------|
| 構文エラー | ビジネスロジックの妥当性 |
| セキュリティの基本 | UX/UIの妥当性 |
| パフォーマンスの基本 | エッジケースの想定 |
| コーディング規約 | 長期的な保守性 |

### レビューチェックリスト

人間のレビュー漏れを防ぐため、チェックリストを用意します。

```markdown
## コードレビューチェックリスト

### 機能性
- [ ] 要件定義書の仕様を満たしているか
- [ ] 設計書と整合性が取れて���るか
- [ ] エッジケースに対応しているか

### コード品質
- [ ] 可読性は高いか
- [ ] 命名規則は統一されているか
- [ ] 不要なコードはないか

### セキュリティ
- [ ] AIの指摘事項は修正されているか
- [ ] 入力値はバリデーションされているか
- [ ] 認証・認可は適切か

### パフォーマンス
- [ ] AIの指摘事項は修正されているか
- [ ] N+1クエリはないか
- [ ] キャッシュは適切に使われているか

### テスト
- [ ] ユニットテストは十分か
- [ ] テストは実際に通るか
```

## GitHubでのAIレビュー統合

GitHub Actions でAIレビューを自動化できます。

```yaml
# .github/workflows/code-review.yml
name: AI Code Review

on:
  pull_request:
    branches: [main]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: AI Code Review
        uses: anthropics/claude-code-review@v1
        with:
          files: '**/*.ts'
          rules: '@.claude/code-review-rules.md'
          
      - name: Post Review Comments
        uses: actions/github-script@v6
        with:
          script: |
            // AIレビュー結果をPRにコメント
```

## まとめ：AIコードレビューのベストプラクティス

| ステップ | 内容 | ツール |
|---------|------|-------|
| 1 | AIで基本的なレビュー | Cursor / Claude Code |
| 2 | 設計書との整合性チェック | AI + @記法 |
| 3 | 要件定義書との整合性チェック | AI + @記法 |
| 4 | AIが指摘した問題を修正 | AI |
| 5 | 人間が最終レビュー | 人間 + チェックリスト |
| 6 | 承認・マージ | 人間 |

**重要な原則**

1. **AIで自動化できる部分は任せる**：構文、セキュリティ基本、パフォーマンス基本
2. **設計書・要件定義書を参照させる**：@記法で正確に伝える
3. **人間が最終判断する**：ビジネスロジック、UX、長期保守性
4. **チェックリストを活用**：人間のレビュー漏れを防ぐ
5. **GitHub Actionsで自動化**：プルリクエストごとに自動レビュー

マークダウン駆動開発では、要件定義書と設計書がマークダウンで存在するため、AIに正確な情報を与えて高品質なコードレビューが実現できます。

次のセクションでは、AIでテストコードを自動生成する方法を学びます。
