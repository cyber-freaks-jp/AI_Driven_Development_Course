# AIでテストコードを自動生成する

実装が完了したら、テストコードを作成します。

「そもそもテストコードって何？」という方は、「TDD（テスト駆動開発）」を勉強しましょう

## テスト生成に必要な3つの情報源

AIに質の高いテストコードを生成させるには、**3つの情報源を参照させる**ことが重要です。

- 要件定義書
- 設計書
- 実装コード

この3つを組み合わせることで、**仕様を満たし、実装と一致した、網羅性の高いテストコード**をAIが生成できます。

## AIでテストを生成してみよう

例として、ECサイトの決済APIに対するテストコードを生成してみます。

### 基本的なユニットテスト生成

実装コード、設計書、要件定義書を参照させて、ユニットテストを生成します。

```
プロンプト：
「@backend/src/routes/payment.ts
@docs/設計書.md
@docs/要件定義書.md
を参照して、決済Intent作成APIのユニットテストを作成してください。

テストファイルは backend/tests/routes/payment.test.ts に実装してください。

以下のテストケースを含めてください：
- 正常系：有効な金額で決済Intent作成成功
- 異常系：最低金額未満（100円未満）でバリデーションエラー
- 異常系：認証なしでアクセスした場合の401エラー
- 異常系：Stripe APIエラー時のエラーハンドリング

Jestを使用してください。」
```

AIが以下のようなテストコードを自動生成してくれます

```typescript
// backend/tests/routes/payment.test.ts
import request from 'supertest';
import app from '../../src/app';
import { stripe } from '../../src/lib/stripe';

jest.mock('../../src/lib/stripe');

describe('POST /api/payment/create-intent', () => {
  it('正常系：有効な金額で決済Intent作成成功', async () => {
    const response = await request(app)
      .post('/api/payment/create-intent')
      .set('Authorization', 'Bearer valid-token')
      .send({ amount: 1000, currency: 'jpy' });

    expect(response.status).toBe(201);
    expect(response.body.clientSecret).toBeDefined();
  });

  it('異常系：最低金額未満でバリデーションエラー', async () => {
    const response = await request(app)
      .post('/api/payment/create-intent')
      .set('Authorization', 'Bearer valid-token')
      .send({ amount: 50, currency: 'jpy' });

    expect(response.status).toBe(400);
    expect(response.body.error).toContain('最低金額は100円');
  });

  // ... 他のテストケース
});
```

### カバレッジ確認と追加テスト生成

テストを実行してカバレッジを確認し、不足している部分のテストを追加します。

```
プロンプト：
「@backend/src/routes/payment.ts のテストカバレッジが65%です。
カバレッジを90%以上にするための追加テストを作成してください。

特に、以下の関数のテストが不足しています：
- 返金処理 (POST /api/payment/:id/refund)
- 決済履歴取得 (GET /api/payment/history)

既存のテストファイル @backend/tests/routes/payment.test.ts に追加してください。」
```

AIが不足しているテストケースを追加してくれます。

## テストの階層とそれぞれのアプローチ

テストには階層があり、それぞれに適したアプローチがあります。

### ユニットテスト：関数・クラス単位

個別の関数やクラスメソッドが正しく動作するかをテストします。

```
プロンプト例：
「@backend/src/services/paymentService.ts の
validatePaymentAmount() 関数のユニットテストを作成してください。

正常系・異常系・エッジケース（0円、負の数、最大値超過）を含めてください。」
```

### 統合テスト：API・エンドポイント単位

複数のコンポーネントを組み合わせた、APIエンドポイント全体の動作をテストします。

```
プロンプト例：
「決済APIの統合テストを作成してください。

以下のシナリオをテストしてください：
1. ユーザー認証
2. 決済Intent作成
3. 決済確認
4. 決済履歴取得

データベースとStripe APIのモックを使用してください。」
```

### E2Eテスト：ユーザーシナリオ単位

ユーザーが実際に操作する流れ全体をブラウザで自動テストします。

```
プロンプト例：
「ECサイトの購入フローのE2Eテストを作成してください。

シナリオ：
1. 商品ページにアクセス
2. カートに追加
3. チェックアウト画面に遷移
4. クレジットカード情報を入力
5. 決済完了を確認

Playwrightを使用してください。」
```

それぞれの階層で適切なテストを生成することで、**品質を多角的に保証**できます。

## AIによるテストレビュー戦略

テストコードを生成した後、**AIにテストケースの漏れを指摘させる**ことで、網羅性を高めることができます。

これは逆向きのアプローチです。要件定義書・設計書と既存のテストコードを突き合わせて、AIに「何が足りないか」を指摘させます。

```
プロンプト：
「@docs/要件定義書.md と @docs/設計書.md を確認してください。
@backend/tests/routes/payment.test.ts の既存テストコードをレビューし、
不足しているテストケースを指摘してください。

特に以下の観点でチェックしてください：
- 要件定義書の機能要件がすべてテストされているか
- エッジケースのテストが不足していないか
- エラーハンドリングのテストが十分か
- セキュリティ関連のテストがあるか」
```

AIが不足しているテストケースを指摘してくれます：

```markdown
## 不足しているテストケース

### 1. 返金処理のテスト
要件定義書に「返金機能」の記載がありますが、テストが見つかりません。
以下のテストが必要です：
- 全額返金
- 部分返金
- 返金済み決済への再返金エラー

### 2. 決済金額の上限チェック
設計書に「1回の決済上限は100万円」とありますが、このバリデーションテストが不足しています。

### 3. 通貨コードのバリデーション
設計書では JPY と USD のみサポートとなっていますが、無効な通貨コードのテストがありません。
```

このように、AIに「テストの穴」を見つけさせることで、**人間が見落としがちなテストケース**を補完できます。

## テスト生成のプロンプトパターン

効果的なテストを生成するための、4つのプロンプトパターンを紹介します。

### パターン1：情報源を明示する（@記法）

```
「@backend/src/routes/payment.ts
@docs/設計書.md
@docs/要件定義書.md
を参照して、テストを作成してください。」
```

**効果**: AIが仕様を正確に理解し、実装と一致したテストを生成できます。

### パターン2：テストフレームワークを指定する

```
「Jestを使用してください。
モックはjest.mock()を使用してください。
アサーションはexpect()を使用してください。」
```

**効果**: プロジェクトの技術スタックに合わせた、一貫性のあるテストコードが生成されます。

### パターン3：正常系・異常系・エッジケースを明示する

```
「以下のテストケースを含めてください：
- 正常系：成功パターン
- 異常系：バリデーションエラー
- 異常系：認証エラー
- 異常系：権限エラー
- エッジケース：境界値（0, 負の数, 最大値超過）」
```

**効果**: 網羅性の高いテストが生成され、見落としがちなケースもカバーできます。

### パターン4：出力先を明確にする

```
「テストファイルは backend/tests/routes/payment.test.ts に実装してください。」
```

**効果**: AIが正しいディレクトリ構造でファイルを作成し、プロジェクトの規約に沿った配置になります。

これら4つのパターンを組み合わせることで、**高品質なテストコードを効率的に生成**できます。

## よくある失敗パターンと対処法

AIでテストを生成する際の、よくある失敗パターンと対処法を紹介します。

### パターン1：プロンプトが曖昧でテストが不完全

**症状**: 生成されたテストが正常系のみで、異常系やエッジケースが不足している。

**原因**: プロンプトで「テストを作成して」とだけ指示し、具体的なテストケースを明示していない。

**対処法**:
```
❌ 悪い例：「payment.ts のテストを作成して」

✅ 良い例：「payment.ts のテストを作成してください。
正常系・異常系（バリデーションエラー、認証エラー）・
エッジケース（境界値）を含めてください。」
```

### パターン2：要件定義書が不十分で網羅性が低い

**症状**: AIが生成したテストが、実際の要件を満たしていない。

**原因**: 要件定義書が曖昧、または古い情報のまま更新されていない。

**対処法**:
1. まず要件定義書を最新化する
2. AIに要件定義書を参照させてテストを生成
3. AIに不足テストケースを指摘させる（レビュー戦略）

### パターン3：生成されたテストが実装と乖離している

**症状**: テストを実行すると、関数名やパスが一致せずエラーになる。

**原因**: 実装コードを参照させずにテストを生成した。

**対処法**:
```
✅ 必ず実装コードを参照させる：
「@backend/src/routes/payment.ts を参照して、
このファイルの実装に合わせたテストを作成してください。」
```

これらの失敗パターンを意識することで、**一発で使えるテストコード**を生成できるようになります。

## AIの限界と人間の役割

AIは効率的にテストコードを生成できますが、**人間による最終確認が不可欠**です。

### AIが生成したテストの妥当性確認

AIが生成したテストコードは、以下の観点で人間が確認する必要があります：

1. **ビジネスロジックの妥当性**
   - テストケースが実際のビジネス要件を満たしているか
   - エッジケースの想定が現実的か

2. **テストの実行可能性**
   - 生成されたテストが実際に実行できるか
   - モックが適切に設定されているか

3. **テストの保守性**
   - テストコードが読みやすく、将来的に保守しやすいか

### ビジネスロジックの理解が必要なケース

以下のようなケースでは、人間の判断が重要です：

- **複雑な業務ルール**: 「月末締めの請求処理」など、業務特有のロジック
- **例外処理**: 「エラー時の補償処理」など、ビジネス判断が必要な処理
- **ユーザー体験**: 「ローディング表示のタイミング」など、UX観点のテスト

### セキュリティ・パフォーマンステストの特殊性

セキュリティやパフォーマンスのテストは、**専門的な知識が必要**です：

- **セキュリティテスト**: SQLインジェクション、XSS、認証バイパスなど
- **パフォーマンステスト**: 負荷テスト、メモリリーク、レスポンスタイムなど

これらは基本的なテストとは異なるアプローチが必要なため、**AIに生成させた後、専門家がレビュー**することを推奨します。

**AIで自動化できる部分はAIに任せ、人間は最終的な品質判断に集中する。これがAI駆動開発のテスト戦略です。**

## まとめ：AI駆動テストの原則

| 原則 | 内容 |
|------|------|
| **3つの情報源** | 要件定義書・設計書・実装コードを参照させる |
| **階層化** | ユニット・統合・E2Eテストを適切に使い分ける |
| **網羅性** | 正常系・異常系・エッジケースを明示的に指示する |
| **レビュー** | AIに不足テストケースを指摘させる逆向きアプローチ |
| **人間の確認** | ビジネスロジック・セキュリティは人間が最終判断 |

**重要な5つの原則**

1. **3つの情報源を必ず参照させる**：要件定義書・設計書・実装コードの3点セットで網羅性を担保
2. **プロンプトを具体的にする**：「テストを作って」ではなく、テストケースを明示する
3. **AIにレビューさせる**：生成後、AIに不足テストケースを指摘させる
4. **カバレッジを確認する**：90%以上を目指し、不足分を追加生成
5. **人間が最終確認する**：ビジネスロジック・セキュリティは人間が判断

次の章では、リファクタリングをAIで自動化する方法を学びます。
