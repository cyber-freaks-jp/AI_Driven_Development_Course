# ルールファイルを設定しよう

## はじめに

Cursorのルールファイル（`.cursorrules`）を設定することで、プロジェクト固有のコーディング規約やベストプラクティスをAIに伝えることができます。これにより、より一貫性のある高品質なコードが生成されます。

## ルールファイルとは

### 基本概念

**`.cursorrules` ファイル：**
- プロジェクトのルートディレクトリに配置
- AIへの指示をまとめたテキストファイル
- コーディング規約、設計方針、制約などを記述
- Cursorがコード生成時に自動的に参照

### なぜ必要なのか

**ルールファイルなし：**
- AIが一般的な方法でコードを生成
- プロジェクトの規約と異なる可能性
- 毎回同じ指示を繰り返す必要

**ルールファイルあり：**
- プロジェクト固有の規約に従ったコード生成
- チーム全体で一貫性のあるコード
- 指示を繰り返す手間が不要

## 基本的な設定方法

### ステップ1：ファイル作成

プロジェクトのルートディレクトリに `.cursorrules` ファイルを作成：

```bash
# プロジェクトのルートで実行
touch .cursorrules
```

または、Cursorで直接作成：
1. Cmd + N で新規ファイル
2. 内容を記述
3. `.cursorrules` として保存

### ステップ2：ルールを記述

基本的なテンプレート：

```markdown
# プロジェクトのコーディング規約

## 言語とフレームワーク
- TypeScript を使用
- React 18
- Next.js 14

## コーディングスタイル
- 関数コンポーネントを使用
- アロー関数を優先
- 2スペースインデント
- セミコロンあり

## 命名規則
- コンポーネント：PascalCase（例：UserProfile）
- 関数・変数：camelCase（例：getUserData）
- 定数：UPPER_SNAKE_CASE（例：API_BASE_URL）
- ファイル：kebab-case（例：user-profile.tsx）

## 必須事項
- すべての関数にJSDocコメント
- エラーハンドリング必須
- TypeScriptの型定義を厳密に
```

### ステップ3：確認

Cursorを再起動するか、プロジェクトを開き直すと、`.cursorrules` が自動的に読み込まれます。

## 実践例

### 例1：React + TypeScript プロジェクト

**.cursorrules:**
```markdown
# React + TypeScript プロジェクト規約

## 技術スタック
- React 18 with TypeScript
- Vite
- TailwindCSS
- React Query for data fetching
- Zustand for state management

## コンポーネント設計
- 関数コンポーネントのみ使用
- propsの型定義は必須
- デフォルトエクスポート禁止（named exportのみ）
- 1ファイル1コンポーネント

## スタイル
- TailwindCSSのユーティリティクラス使用
- インラインスタイル禁止
- カスタムCSSは最小限に

## ファイル構造
```
src/
  components/
    common/      # 共通コンポーネント
    features/    # 機能別コンポーネント
  hooks/         # カスタムフック
  utils/         # ユーティリティ関数
  types/         # 型定義
```

## コーディング規約
- すべての関数にJSDoc
- 早期リターンを活用
- magic numberは定数化
- 非同期処理はasync/await使用

## エラーハンドリング
- try-catchで例外を捕捉
- エラーはtoastで通知
- ログはconsole.errorで出力

## 禁止事項
- any型の使用
- console.log（開発時を除く）
- デッドコード
- 未使用のimport
```

### 例2：Node.js API プロジェクト

**.cursorrules:**
```markdown
# Node.js API プロジェクト規約

## 技術スタック
- Node.js 20
- Express.js
- TypeScript
- PostgreSQL with Prisma
- JWT for authentication

## アーキテクチャ
- レイヤードアーキテクチャ
  - Controller: リクエスト・レスポンス処理
  - Service: ビジネスロジック
  - Repository: データアクセス

## API設計
- RESTful API
- HTTPステータスコードを適切に使用
  - 200: 成功
  - 201: 作成成功
  - 400: バリデーションエラー
  - 401: 認証エラー
  - 403: 権限エラー
  - 404: Not Found
  - 500: サーバーエラー

## セキュリティ
- パスワードはbcryptでハッシュ化
- JWTトークンは環境変数で管理
- SQLインジェクション対策（Prisma使用）
- CORS設定必須

## エラーハンドリング
- カスタムエラークラスを使用
- エラーミドルウェアで一元管理
- 詳細なエラーログ

## バリデーション
- リクエストボディは必ずバリデーション
- Zod または Joi を使用

## テスト
- すべてのエンドポイントにテストを作成
- Jest + Supertest使用
```

### 例3：Python プロジェクト

**.cursorrules:**
```markdown
# Python プロジェクト規約

## 技術スタック
- Python 3.11+
- FastAPI
- SQLAlchemy
- Pytest

## コーディングスタイル
- PEP 8 準拠
- 4スペースインデント
- 型ヒント必須（typing モジュール使用）
- docstring必須（Google形式）

## 命名規則
- クラス：PascalCase
- 関数・変数：snake_case
- 定数：UPPER_SNAKE_CASE
- プライベート：_先頭にアンダースコア

## ファイル構造
```
src/
  api/          # API endpoints
  models/       # データモデル
  services/     # ビジネスロジック
  repositories/ # データアクセス
  schemas/      # Pydanticスキーマ
  utils/        # ユーティリティ
```

## 必須事項
- すべての関数に型ヒント
- すべての関数にdocstring
- エラーハンドリング必須

## エラーハンドリング
- HTTPExceptionを使用
- カスタム例外クラスを定義
- try-exceptで例外を捕捉

## データベース
- SQLAlchemy ORMを使用
- マイグレーションはAlembic
- トランザクション管理を徹底
```

## 高度な設定例

### プロジェクト全体のルール

**.cursorrules:**
```markdown
# プロジェクト全体の規約

## プロジェクト概要
このプロジェクトは、タスク管理SaaSアプリケーションです。
ユーザーはプロジェクトを作成し、タスクを管理できます。

## 技術スタック
- フロントエンド：Next.js 14 + TypeScript + TailwindCSS
- バックエンド：Node.js + Express + TypeScript
- データベース：PostgreSQL + Prisma
- 認証：JWT + httpOnly Cookie

## アーキテクチャパターン
- フロントエンド：Feature-Sliced Design
- バックエンド：Clean Architecture

## 共通ルール

### コードの品質
1. **可読性優先**
   - 明確な変数名・関数名
   - 複雑な処理にはコメント
   - 適切な関数分割

2. **保守性**
   - DRY原則（Don't Repeat Yourself）
   - SOLID原則に従う
   - テストコードも同様に保守

3. **パフォーマンス**
   - 不要な再レンダリングを避ける
   - データベースクエリを最適化
   - 適切なインデックス設定

### セキュリティ
- パスワードは必ずハッシュ化
- シークレットは環境変数
- XSS、CSRF対策
- 入力値は必ずバリデーション

### Git運用
- コミットメッセージは英語
- Conventional Commits形式
  - feat: 新機能
  - fix: バグ修正
  - refactor: リファクタリング
  - docs: ドキュメント
  - test: テスト

### ドキュメント
- READMEは最新に保つ
- API仕様はSwagger/OpenAPIで管理
- 複雑な機能は設計書を作成

## 禁止事項
- any型、unknown型の多用
- 未処理のPromise
- console.log の本番環境への残存
- ハードコードされたシークレット
- 未テストのコード
```

## ルールファイルの活用方法

### 1. Composerでの利用

Composerに指示するだけで、`.cursorrules` が自動的に適用されます：

```
新しいユーザー管理機能を追加してください。
```

Cursorは`.cursorrules`の内容を参照して：
- 指定された技術スタックで実装
- 命名規則に従う
- 必要なエラーハンドリングを追加
- テストコードも生成

### 2. Cmd+K での部分修正

```
この関数をリファクタリングしてください
```

`.cursorrules` に基づいて：
- プロジェクトの規約に従った形式
- 適切なコメント追加
- 型定義を厳密に

### 3. コードレビュー

```
@src このコードをレビューして、規約違反を指摘してください
```

Cursorが`.cursorrules`を参照してレビュー。

## チーム開発での活用

### チーム全体で共有

1. `.cursorrules` をGitリポジトリにコミット
2. チームメンバー全員が同じルールを使用
3. コードの一貫性が保たれる

```bash
git add .cursorrules
git commit -m "docs: add cursor rules"
git push
```

### プルリクエストの説明に追加

```markdown
## このPRについて
`.cursorrules` に従って実装しています。
- TypeScript strict mode対応
- エラーハンドリング完備
- ユニットテスト追加済み
```

## よくある質問

### Q1: ルールファイルの長さは？

**A:** 制限はありませんが、簡潔に保つのがベスト。重要なルールに絞りましょう。

### Q2: 複数のルールファイルは使える？

**A:** `.cursorrules` は1ファイルのみ。サブディレクトリごとのルールは未サポート。

### Q3: ルールが適用されない？

**A:** 以下を確認：
- ファイル名が `.cursorrules`（先頭にドット）
- プロジェクトのルートに配置
- Cursorを再起動

### Q4: ルールを一時的に無視したい

**A:** プロンプトで明示的に指示：
```
.cursorrulesを無視して、以下のように実装してください：
[具体的な指示]
```

## ベストプラクティス

### 1. 段階的に追加

最初から完璧なルールは不要：
1. 基本的なルールから開始
2. 問題が起きたらルール追加
3. チームで議論して更新

### 2. 具体的な例を含める

❌ **悪い例：**
```
関数にはコメントをつける
```

✅ **良い例：**
```
すべての関数にJSDocコメントを追加：

/**
 * ユーザー情報を取得する
 * @param userId - ユーザーID
 * @returns ユーザー情報
 * @throws {NotFoundError} ユーザーが見つからない場合
 */
async function getUser(userId: string): Promise<User> {
  // ...
}
```

### 3. 禁止事項を明確に

```markdown
## 禁止事項
✗ any型の使用（unknown型を検討）
✗ var の使用（const, let を使用）
✗ == の使用（=== を使用）
✗ マジックナンバー（定数化）
```

### 4. チェックリストを含める

```markdown
## コード提出前のチェックリスト
- [ ] TypeScriptのエラーがない
- [ ] Lintエラーがない
- [ ] テストが全て通る
- [ ] 型定義が適切
- [ ] エラーハンドリング実装済み
- [ ] コメント・ドキュメント追加済み
```

## サンプルテンプレート

### シンプル版

```markdown
# プロジェクトルール

## 技術スタック
[使用している技術を列挙]

## コーディングスタイル
[インデント、命名規則など]

## 必須事項
[必ず守るべきルール]

## 禁止事項
[やってはいけないこと]
```

### 詳細版

プロジェクトルートに以下のファイルを作成：

```markdown
# [プロジェクト名] コーディング規約

## 1. プロジェクト概要
[プロジェクトの説明]

## 2. 技術スタック
[技術スタック]

## 3. アーキテクチャ
[採用しているアーキテクチャパターン]

## 4. ディレクトリ構造
[ファイル・フォルダの配置ルール]

## 5. コーディング規約
### 5.1 命名規則
[命名のルール]

### 5.2 スタイル
[インデント、空白など]

### 5.3 コメント
[コメントのルール]

## 6. 設計原則
[SOLID、DRYなどの原則]

## 7. エラーハンドリング
[エラー処理の方針]

## 8. テスト
[テストの方針]

## 9. セキュリティ
[セキュリティ要件]

## 10. パフォーマンス
[パフォーマンス要件]

## 11. 禁止事項
[やってはいけないこと]

## 12. 推奨事項
[やったほうが良いこと]
```

## まとめ

**ルールファイルの効果：**

✓ 一貫性のあるコード生成
✓ チーム全体での規約統一
✓ 毎回の指示が不要
✓ コードレビューが楽になる
✓ 新メンバーのオンボーディングが簡単

**設定のポイント：**

1. **段階的に追加**
   - 最初はシンプルに
   - 必要に応じて拡張

2. **具体的に記述**
   - 曖昧な表現を避ける
   - 例を含める

3. **チームで共有**
   - Gitで管理
   - 定期的に見直し

4. **実践的な内容**
   - 実際に使うルールに絞る
   - 理想論より実用性

`.cursorrules` を設定することで、Cursorがプロジェクト専属のAIエンジニアになります！
