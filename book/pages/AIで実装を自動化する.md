# AIで実装を自動化する

要件定義書・設計書が完成したら、いよいよ実装フェーズです。
実装フェーズでは**タスクを適切に分割すること**が非常に重要です。

この章では、**実装フェーズならではのAI活用のポイント**を、ECサイトの決済機能を例に学びます。

## ECサイトの決済機能を実装してみよう

要件定義と設計で決めたECサイトに、決済機能を実装していきます。

### ステップ1：バックエンドAPIの実装

まず、Cursorで決済APIを実装します。

```
プロンプト：
「@docs/要件定義書.md と @docs/設計書.md を参照して、
決済機能のバックエンドAPIを実装してください。

ファイル: backend/src/routes/payment.ts
エンドポイント: POST /api/payment/create-intent
決済ツール: Stripe

以下を含めてください：
- リクエストボディのバリデーション
- エラーハンドリング
- レスポンスの型定義

既存の認証ミドルウェア @backend/src/middleware/auth.ts を使用してください。」
```

**ポイント：**
- `@記法`で要件定義書と設計書を同時に参照させる
- 可能な限りタスクを分割し、明確に指示する

### ステップ2：動作確認してエラーに対処する

実装したコードを実行してみます。

```bash
cd backend
npm run dev
```

すると、以下のエラーが出たとします：

```
TypeError: Cannot read property 'client_secret' of undefined
```

このエラーメッセージをAIに伝えて修正します。

```
プロンプト：
「@backend/src/routes/payment.ts を実行すると、以下のエラーが出ました：

TypeError: Cannot read property 'client_secret' of undefined
  at /backend/src/routes/payment.ts:24:56

原因を特定して修正してください。」
```

AIが原因を分析して修正案を提示してくれます：

```
AI：
「paymentIntent.client_secret が undefined になっています。
原因は、Stripe APIの呼び出しが失敗している可能性があります。
以下を確認してください：

1. 環境変数 STRIPE_SECRET_KEY が設定されているか
2. Stripe APIキーが正しいか

また、エラーハンドリングを改善して、Stripe APIのエラーもキャッチするようにします。」
```

そして、修正されたコードを生成してくれます。

### ステップ3：既存コードとの整合性を保つ

次に、注文情報と決済を連携させます。

```
プロンプト：
「@backend/src/routes/payment.ts の決済処理を、
@backend/src/models/Order.ts の既存のOrder型と連携させてください。

決済成功時に、Order レコードを作成して、
order.paymentStatus を 'paid' に設定してください。」
```

**ポイント：**
- 複数の既存ファイルを`@記法`で参照させる
- 既存の型定義やモデルとの整合性を明示的に指示する

AIが既存コードを確認して、整合性を保ったコードを生成してくれます。

### ステップ4：フロントエンドの実装

バックエンドが完成したら、フロントエンドを実装します。

```
プロンプト：
「@backend/src/routes/payment.ts のAPIを呼び出す
決済フォームコンポーネントを実装してください。

ファイル: frontend/src/components/CheckoutForm.tsx

以下を含めてください：
- Stripe Elements を使用
- カード情報入力フォーム
- 決済ボタン
- ローディング状態の表示
- エラーハンドリング
- 決済成功時にサンクスページへ遷移」
```

このように、バックエンドのコードを`@記法`で参照させることで、APIの仕様を正確に理解したフロントエンドコードが生成されます。

## エラーが出たときの対処法

実装フェーズでは、エラーに遭遇することが頻繁にあります。AIを使ってエラーを解決する方法を学びましょう。

### パターン1：TypeScriptの型エラー

**状況：** ビルド時に型エラーが出た

```
エラー：
Type 'string | undefined' is not assignable to type 'string'.
  in backend/src/routes/payment.ts:18
```

**対処法：**

```
プロンプト：
「@backend/src/routes/payment.ts で以下の型エラーが出ています：

Type 'string | undefined' is not assignable to type 'string'.
  at line 18

原因を特定して修正してください。」
```

AIが原因を分析して、型ガードやnullチェックを追加してくれます。

### パターン2：実行時エラー

**状況：** APIを呼び出すとサーバーエラーが発生

```
エラー：
Error: Stripe API error: Invalid API Key provided
  at stripe.paymentIntents.create
```

**対処法：**

```
プロンプト：
「POST /api/payment/create-intent を呼び出すと、以下のエラーが発生しました：

Error: Stripe API error: Invalid API Key provided

エラーログ：
[スタックトレース全文]

@backend/src/routes/payment.ts を確認して、原因と対策を教えてください。」
```

**ポイント：**
- エラーメッセージの全文をコピペする
- スタックトレースも含める
- どのファイルを確認すべきかを`@記法`で指定する

### パターン3：期待通りに動かない

**状況：** エラーは出ないが、期待した動作をしない

```
問題：
POST /api/payment/create-intent を呼び出すと、
ステータスコード200が返りますが、レスポンスボディが空です。

期待するレスポンス：
{ clientSecret: "pi_xxx_secret_yyy" }

実際のレスポンス：
{}
```

**対処法：**

```
プロンプト：
「@backend/src/routes/payment.ts の動作がおかしいです。

期待する動作：
POST /api/payment/create-intent
レスポンス: { clientSecret: string }

実際の動作：
ステータスコード200が返るが、レスポンスボディが空 {}

原因を特定して修正してください。」
```

**ポイント：**
- **期待する動作**と**実際の動作**を明確に伝える
- エラーが出ない場合でも、AIは問題を特定できる

## CursorとClaude Codeの実践的な使い分け

実装フェーズでは、CursorとClaude Codeを使い分けることで効率が上がります。

### シーン1：重要な新機能の実装（Cursorで）

**使うべき場面：**
- 決済機能のような重要な実装
- セキュリティに関わる実装
- 複雑なビジネスロジック

**理由：**
- Cmd+Iで対話しながら進められる
- 各ステップで承認しながら実装できる
- 間違った実装をすぐに修正できる

**使い方：**
```
Cmd+I → プロンプト入力 → AIの提案を確認 → 承認 → 実装
```

### シーン2：定型的な実装（Claude Codeで）

**使うべき場面：**
- CRUD操作の実装
- シンプルなコンポーネント
- テストコードの生成

**理由：**
- 完全自動実行で効率化できる
- 定型的なコードなのでリスクが低い
- 大量のファイルを一度に生成できる

**使い方：**
```bash
claude-code --dangerously-skip-permissions "商品一覧APIのCRUD操作を実装して"
```

詳しくは[ClaudeCodeの紹介](./ClaudeCodeの紹介.md)を参照してください。

### シーン3：デバッグ（Cursorで）

**使うべき場面：**
- エラーが出たとき
- 期待通りに動かないとき
- 原因を特定したいとき

**理由：**
- エラーメッセージを見せながら対話できる
- 段階的に原因を絞り込める
- 複数の解決策を提案してもらえる

**使い方：**
```
Cmd+I → エラーメッセージを貼り付け → AIが原因分析 → 修正案を提案 → 承認
```

## ⚠️実装フェーズの心構え

### AIが生成したコードは必ず動作確認する

**AIは完璧ではありません。**

生成されたコードをそのまま信じて、次に進むのは危険です。

必ず以下を実行してください：
- コードを読んで理解する
- ローカル環境で実行してみる
- テストを書いて確認する
- エラーが出たら即座に修正する

### 小さく実装、小さくテスト

**大きな機能を一度に実装しない。**

1つのAPIを実装したら、すぐにテストしましょう：

```bash
# バックエンドのテスト
curl -X POST http://localhost:3000/api/payment/create-intent \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{"amount":1000,"currency":"jpy"}'
```

動かない場合は、すぐにAIに修正させます。

**溜め込まない**のが重要です。

### エラーが出たら即座にAIに修正させる

エラーに遭遇したら、自分で調べる前に、まずAIに相談しましょう。

```
「以下のエラーが出ました：
[エラーメッセージ]

原因と対策を教えてください。」
```

AIはエラーメッセージから原因を特定し、修正案を提示してくれます。

これがAI駆動開発の強みです。

## まとめ

実装フェーズでのAI活用のポイント：

1. **タスクを分割する**
   - 詳しくは[タスク分割の技術](./タスク分割の技術.md)を参照

2. **@記法で複数ファイルを参照させる**
   - 要件定義書、設計書、既存コードを同時に参照
   - 整合性を保った実装が可能

3. **エラーが出たらAIに相談する**
   - エラーメッセージを全文コピペ
   - 期待する動作と実際の動作を明確に伝える

4. **CursorとClaude Codeを使い分ける**
   - 重要な実装：Cursor（対話しながら）
   - 定型的な実装：Claude Code（完全自動）
   - デバッグ：Cursor（対話しながら）

5. **小さく実装、小さくテスト**
   - 1つ実装したら、すぐにテスト
   - 動かない場合は、すぐに修正
   - 溜め込まない

**実装フェーズでもAIは強力な味方です。ただし、生成されたコードを盲信せず、必ず動作確認しましょう。**

次の章では、実装が完了した後のコードレビューをAIで効率化する方法を学びます。
