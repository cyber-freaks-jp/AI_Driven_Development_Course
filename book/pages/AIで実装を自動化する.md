# AIで実装を自動化する

設計書が完成したら、いよいよ実装フェーズです。ここでもAIを最大限活用することで、実装速度と品質を大幅に向上させることができます。

## 設計書から実装を自動生成する流れ

```
設計書.md（マークダウン）
    ↓ AIに読み込ませる
実装コード
    ↓ テスト・修正
完成したコード
    ↓ Gitにコミット
テストフェーズへ
```

## 重要原則：タスクを分割して指示する

実装時の最も重要な原則は、**1つのプロンプトで全てを実装させない**ことです。

### ❌ 悪い例：一括指示

```
「@Docs/設計書.md をもとに、タスク管理アプリを実装してください。
フロントエンド、バックエンド、データベース、全部お願いします。」
```

**問題点**：
- AIが混乱し、不完全なコードを生成
- エラーが多発
- どこで問題が起きたか特定困難
- 修正に膨大な時間がかかる

### ✅ 良い例：分割して指示

```
ステップ1: データベースマイグレーションファイルを作成
ステップ2: バックエンドのモデル層を実装
ステップ3: バックエンドのAPI層を実装
ステップ4: フロントエンドのコンポーネントを実装
ステップ5: フロントエンドとバックエンドを統合
```

**メリット**：
- AIが各タスクに集中できる
- エラーが少ない
- 問題箇所を特定しやすい
- 段階的に動作確認できる

この原則については、「[分割は力なり](./分割は力なり.md)」で詳しく解説しています。

## 実装の進め方：段階的アプローチ

### ステップ1：プロジェクト構成を作成

まず、プロジェクトの基本構成を作成します。

```
プロンプト例：
「タスク管理アプリのプロジェクト構成を作成してください。
以下の構成でお願いします：
- backend/（Node.js + Express + TypeScript）
- frontend/（React + TypeScript + Vite）
- docker-compose.yml（PostgreSQL + Redis）

各ディレクトリに package.json と tsconfig.json も作成してください。」
```

### ステップ2：データベースマイグレーションを作成

次に、データベーススキーマを実装します。

```
プロンプト例：
「@Docs/設計書.md のデータベース設計をもとに、
backend/migrations/ にマイグレーションファイルを作成してください。
以下のテーブルを作成してください：
- users テーブル
- tasks テーブル
- comments テーブル

Knex.js を使用してください。」
```

### ステップ3：バックエンドのモデル層を実装

データベーススキーマができたら、モデル層を実装します。

```
プロンプト例：
「backend/src/models/ に以下のモデルを作成してください：
- User.ts
- Task.ts
- Comment.ts

各モデルには以下のメソッドを含めてください：
- findById
- findAll
- create
- update
- delete

Prisma ORM を使用してください。」
```

### ステップ4：バックエンドのAPI層を実装（1つずつ）

APIは**1つずつ**実装します。まとめて実装しません。

```
プロンプト例（1つ目）：
「@Docs/設計書.md の「POST /api/auth/register」APIを実装してください。
backend/src/routes/auth.ts に実装してください。
以下を含めてください：
- リクエストのバリデーション（Zod使用）
- パスワードのハッシュ化（bcrypt使用）
- エラーハンドリング
- レスポンスの型定義」
```

動作確認後、次のAPIを実装：

```
プロンプト例（2つ目）：
「「POST /api/auth/login」APIを実装してください。
backend/src/routes/auth.ts に追加してください。」
```

このように**1つずつ**進めます。

### ステップ5：フロントエンドのコンポーネントを実装（1つずつ）

フロントエンドも**1つずつ**実装します。

```
プロンプト例（1つ目）：
「frontend/src/components/LoginForm.tsx を作成してください。
以下の仕様で実装してください：
- メールアドレスとパスワードの入力フォーム
- バリデーション（React Hook Form使用）
- POST /api/auth/login を呼び出し
- エラー表示
- ローディング状態の表示」
```

動作確認後、次のコンポーネントを実装：

```
プロンプト例（2つ目）：
「frontend/src/components/TaskList.tsx を作成してください。」
```

## 実装時のベストプラクティス

### 1. @記法で設計書を参照させる

```
✅ 良い例：
「@Docs/設計書.md の「3.1 POST /api/auth/register」APIを実装してください。」
```

これにより、AIが設計書の内容を正確に理解できます。

### 2. 実装する範囲を明確にする

```
✅ 良い例：
「backend/src/routes/tasks.ts に、
GET /api/tasks エンドポイントのみを実装してください。
他のエンドポイントは実装しないでください。」
```

### 3. 使用技術を明示する

```
✅ 良い例：
「バリデーションは Zod を使用してください。
ORMは Prisma を使用してください。
認証は JWT を使用してください。」
```

### 4. エラーハンドリングを忘れない

```
✅ 良い例：
「エラーハンドリングも実装してください。
以下のエラーケースを考慮してください：
- バリデーションエラー（400）
- 認証エラー（401）
- 権限エラー（403）
- リソース不在（404）
- サーバーエラー（500）」
```

### 5. 型安全性を確保する

```
✅ 良い例：
「TypeScriptの型定義を厳密に行ってください。
リクエスト、レスポンス、内部データ構造すべてに型を付けてください。
any型は使用しないでください。」
```

## 動作確認を忘れずに

各ステップで動作確認を行います。

```bash
# バックエンドのテスト
cd backend
npm test

# 手動でAPIを確認
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123"}'

# フロントエンドの起動
cd frontend
npm run dev
```

問題があれば、その箇所だけをAIに修正させます：

```
プロンプト例：
「@backend/src/routes/auth.ts の register エンドポイントで、
パスワードが8文字未満の場合にエラーが返されません。
バリデーションを追加してください。」
```

## 大規模な機能も分割して実装

複雑な機能は、さらに細かく分割します。

### 例：タスク一覧表示機能

```
ステップ1: データ取得APIの実装（GET /api/tasks）
ステップ2: タスク一覧コンポーネントの実装（TaskList.tsx）
ステップ3: タスクアイテムコンポーネントの実装（TaskItem.tsx）
ステップ4: フィルタリング機能の追加
ステップ5: ページネーション機能の追加
ステップ6: ソート機能の追加
```

各ステップで動作確認し、問題があれば修正してから次へ進みます。

## Claude CodeとCursorの使い分け

### Cursorで実装（手動承認あり）

```
- メイン機能の実装
- 重要なロジック
- 複雑なアルゴリズム
```

Cursorは`Cmd+I`や`Cmd+K`で承認しながら実装できるため、重要な実装に向いています。

### Claude Codeで実装（完全自動）

```
- 定型的なCRUD操作
- シンプルなコンポーネント
- テストコード
```

Claude Codeは`--dangerously-skip-permissions`で完全自動実行できるため、定型的な実装に向いています。

詳しくは「[ClaudeCodeの紹介](./ClaudeCodeの紹介.md)」を参照してください。

## まとめ：実装自動化のポイント

| ポイント | 内容 |
|---------|------|
| **分割** | 1つのプロンプトで全部実装しない |
| **段階的** | ステップバイステップで進める |
| **参照** | @記法で設計書を参照させる |
| **明確** | 実装範囲と使用技術を明示する |
| **確認** | 各ステップで動作確認する |
| **修正** | 問題があれば即座に修正する |

**重要な原則**

1. **タスクを分割する**：1つのプロンプトで複数の機能を実装させない
2. **段階的に進める**：前のステップが完了してから次へ
3. **設計書を参照させる**：@記法で正確に情報を伝える
4. **動作確認を怠らない**：各ステップで必ずテストする
5. **分割は力なり**：複雑な機能も分割すれば簡単になる

この原則を守ることで、AIによる実装の精度が劇的に向上します。

詳細は「[分割は力なり](./分割は力なり.md)」を参照してください。

次のセクションでは、実装が完了した後、AIでテストコードを自動生成する方法を学びます。
